<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Blog on Computer Science, FP, and other things</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />

        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
          }
        });
        </script>
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="./">Blog</a>
                <a href="https://github.com/davnils" target="_blank">Code</a>
                <a href="./about.html">About</a>
            </div>
        </div>

        <div id="content">
            <h1>Blog on Computer Science, FP, and other things</h1>
            
  <a href="#Reliable Blind SQL Injections"></a>
  <div class="post">
<h2>Reliable Blind SQL Injections</h2>

<div class="info">
  Posted on June 20, 2013
</div>

  <h4 id="introduction">Introduction</h4>
<p>This post will study the problem of reliably detecting blind SQL injections, and more specifically how statistic methods can be utilized.</p>
<p>First lets begin with defining blind SQL injections. Basically a SQL injection is considered blind when there is no direct result being observed in the reply generated by a server, but it still executes code supplied by an attacker. Hence one option is to resort to observing side-effects, e.g. timing, external connections etc. The focus of this post is to provide more reliable detection of timing-based blind SQL injections.</p>
<p>Typically blind SQL injections are detected by running a query which consumes a lot of time. Such a query might for example be <i>sleep 5000</i>, which would delay the server response in 5 seconds. There are some basic potential issues with this approach:</p>
<ul>
<li>There is an implicit assumption of some deterministic (in the time domain) function, such as <i>sleep</i>.</li>
<li>Large sleep intervals (or heavy computations) will be easy to detect when monitoring a system. After all they would be chosen as to stand out of the typical response time distribution.</li>
<li>Load fluctuations on the server side and networks effect will make it less reliable.</li>
<li>Large offsets may result in server timeouts.</li>
</ul>
<h4 id="statistical-approach">Statistical approach</h4>
<p>Before describing a statistical model of deciding if a blind SQL injection actually exists, I will describe some desirable goals.</p>
<p>First of all, it would be great to make all underlying assumptions clear and describe relationships between different parameters, i.e. having a well-defined problem. It would also be great to generalize the <i>blind SQL</i> part to other databases and different kind of queries.</p>
<p>A basic assumption would be to have a payload executed on the target machine resulting in a <i>significant</i> delay, before it transmits the reply. This is rather vaguely worded but will be heavily dependent on parameters, as presented in the coming section.</p>
<p>Given the ability to submit some passive probe <span class="math"><em>f</em><sub><em>p</em><em>a</em><em>s</em><em>s</em><em>i</em><em>v</em><em>e</em></sub></span> (a normal request) and some active probe <span class="math"><em>f</em><sub><em>a</em><em>c</em><em>t</em><em>i</em><em>v</em><em>e</em></sub></span> (with the potential injection), it is possible to build two distributions of response times. You can think of the distributions as two histograms (or tables) of values. This allows us to incorporate information from several requests into deciding if there actually exists a blind SQL injection. The basic approach is to either reject the possibility of a blind SQL injection or keep on making requests, hence adding more information. The goal would then be to tell if there is a significant deviation between the distributions, a problem which can be handled using statistics.</p>
<h4 id="bootstrap-and-hypothesis-testing">Bootstrap and hypothesis testing</h4>
<p>The section will present the bootstrap and how it can be used to define if two distributions are “equal”, while still not breaking any assumptions.</p>
<p>Given a set of observed values (such as response times of a passive probe) as a vector <span class="math"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, . . . , <em>x</em><sub><em>n</em></sub></span>, we would like to define statistical measures on the underlying distribution. This is typically not trivial since a response time distribution might differ from some <span class="math"><em>N</em>(<em>μ</em>, <em>σ</em><sup>2</sup>)</span> distribution, partly since the central limit theorem is not applicable in the general case.</p>
<p>Non-parameterized bootstrap (the version used here) provides a way of defining a proper distribution based on the given set of samples. It is defined as follows:</p>
<ul>
<li>Given some set of samples <span class="math"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, . . . , <em>x</em><sub><em>n</em></sub></span> drawn from <span class="math"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, . . . , <em>X</em><sub><em>n</em></sub></span> , the distribution formed by <span class="math"><em>X</em> * <sub>1</sub>, <em>X</em> * <sub>2</sub>, . . . , <em>X</em> * <sub><em>n</em></sub></span> can be estimated by taking B samples <span class="math"><em>x</em> * <sub>1</sub>, <em>x</em> * <sub>2</sub>, . . . , <em>x</em> * <sub><em>n</em></sub></span> from the original set (with replacement), and it converges as <span class="math"><em>B</em> →  + ∞</span> (or when all B possible samples have been taken).</li>
</ul>
<p>Underlying this theorem is the idea of <span class="math"><em>X</em> * <sub>1</sub>, <em>X</em> * <sub>2</sub>, . . . , <em>X</em> * <sub><em>n</em></sub></span> representing the acquired samples. Typically the parameter <span class="math"><em>B</em></span> will not cover all possible sets of samples, hence we are left with an approximation (this is due to to the exponential increase with respect to <span class="math"><em>n</em></span>).</p>
<p>Given this distribution it is possible to evaluate different types of estimators, i.e. different statistical measures. In our case it is of interest to study <span class="math"><em>θ</em>(<em>b</em>) = {<em>f</em><sub><em>p</em><em>a</em><em>s</em><em>s</em><em>i</em><em>v</em><em>e</em></sub>}<sub><em>b</em></sub> − {<em>f</em><sub><em>a</em><em>c</em><em>t</em><em>i</em><em>v</em><em>e</em></sub>}<sub><em>b</em></sub></span>, the difference in arithmetic mean between the <span class="math"><em>b</em></span>’th sample of passive and active probes.</p>
<p>By evaluating <span class="math"><em>θ</em>(<em>b</em>)</span> for <span class="math"><em>b</em> = 1, . . . , <em>B</em></span>, for some chosen <span class="math"><em>B</em></span>, a distribution of difference in arithmetic means is constructed. This distribution can then be used to draw statistically sound conclusions, and construct confidence intervals for these results. A confidence interval can be constructed using the <i>percentile method</i>, which basically corresponds to the lower and upper percentiles of the distribution with respect a significance parameter. In this particular case we would like to survey if there is some significant difference indicating that a blind SQL injection does exist. This corresponds to the null hypothesis <span class="math"><em>H</em><sub>0</sub></span> : ‘There is no blind SQL injection’. It will be evaluated over the given distribution for some significance level parameter <span class="math"><em>α</em></span> (typically 0.05 or 0.01). If the null hypothesis is rejected this implies that a blind SQL injection does exist (at the specified significance level), or else no conclusions can be drawn (at least according to this specific definition).</p>
<h4 id="example-implementation">Example implementation</h4>
<p>A sample implementation exists at <a href="https://github.com/davnils/blind-sqli-stats">blind-sqli-stats</a> which implements bootstrap, the percentile method, and hypothesis testing. All input measurements are read from stdin, which would correspond to an asynchronous HTTP request in a real life implementation. It is constructed in a way that only requires a small initial set of samples from <span class="math">{<em>f</em><sub><em>a</em><em>c</em><em>t</em><em>i</em><em>v</em><em>e</em></sub>}</span> and <span class="math">{<em>f</em><sub><em>p</em><em>a</em><em>s</em><em>s</em><em>i</em><em>v</em><em>e</em></sub>}</span>, and will then expand both sets with one element until the null hypothesis is rejected, or some upper limit in the number of samples is reached.</p>
<p>There are also a few sample distributions included. All of these are normally distributed with mixed classifications (i.e. both significant and non-significant examples), but the actual implementation should be able to handle arbitrary distributions.</p>
<p>An important function is ‘rejected’ which decides if, based on the two sets of samples, the null hypothesis should be rejected. It is implemented as follows:</p>
<pre><code>bool rejected(const std::vector&lt;double&gt; &amp; x,
              const std::vector&lt;double&gt; &amp; y)
{
  std::vector&lt;double&gt; bootStrapped;
  bootStrapped.reserve(BOOTSTRAP_SAMPLES);

  for(auto b = 0U; b &lt; BOOTSTRAP_SAMPLES; b++)
  {
    auto xSample = sample(x, x.size());
    auto ySample = sample(y, y.size());

    bootStrapped.push_back(
      average(xSample) - average(ySample)
      );
  }

  std::sort(std::begin(bootStrapped), std::end(bootStrapped));

  auto bounds = getInterval(bootStrapped, SIGNIFICANCE_ALPHA);

  return(bounds.first &gt; 0 || bounds.second &lt; 0);
}</code></pre>
<p>Basically the two input vectors are sampled <span class="math"><em>B</em></span> times and the difference in arithmetic means is saved for each sample. <span class="math"><em>g</em><em>e</em><em>t</em><em>I</em><em>n</em><em>t</em><em>e</em><em>r</em><em>v</em><em>a</em><em>l</em></span> is applied to retrieve the corresponding bounds of the confidence interval, and if zero is excluded then the null hypothesis can be rejected (at SIGNIFICANCE_ALPHA).</p>
<p>Here is an example run demonstrating the ability to detect significant differences:</p>
<pre><code>d@burk:~/work/sqli-stats$ head -n1 data/normal_5
# N(0.3, 1/30) and N(0.29, 1/30)
d@burk:~/work/sqli-stats$ ./out &lt; data/normal_5 
Null hypothesis rejected: blind sql injection highly likely</code></pre>
<h4 id="discussion">Discussion</h4>
<p>This implementation demonstrates how all assumptions have been clear and provides reliable decisions. There are however several parameters that likely need to be tuned to fit the needs of specific implementations and conditions. For example the significance level <span class="math"><em>α</em></span> and the number of bootstrap samples <span class="math"><em>B</em></span> should typically be set according to computational constraints, while still maintaining sound statistic measures.</p>
<p>Some practical issues include choosing the minimum number of samples required from <span class="math">{<em>f</em><sub><em>a</em><em>c</em><em>t</em><em>i</em><em>v</em><em>e</em></sub>}</span> and <span class="math">{<em>f</em><sub><em>p</em><em>a</em><em>s</em><em>s</em><em>i</em><em>v</em><em>e</em></sub>}</span>, and deciding on some upper limit.</p>
<p>Until now all descriptions have been given as the null hypothesis being rejected, or nothing can be concluded. This is of course a naive approach and information regarding probes (e.g. an active probe should result in significant deviation) should allow confirming the non-existence of injections.</p>
<p>I should also mention that the percentile method is very basic and will not render optimal results in all cases. An alternative is the <span class="math"><em>B</em><em>C</em><sub><em>a</em></sub></span> method, which modifies the chosen interval points to account for skew and bias.</p>
</div>

<div class="box"></div>


  <a href="#The Beginning"></a>
  <div class="post">
<h2>The Beginning</h2>

<div class="info">
  Posted on June 16, 2013
</div>

  <p>This post indicates the beginning of this blog, which will cover various problems and projects, mostly related to theoretic computer science, math, and functional programming.</p>
</div>

<div class="box"></div>



        </div>
    </body>
</html>
